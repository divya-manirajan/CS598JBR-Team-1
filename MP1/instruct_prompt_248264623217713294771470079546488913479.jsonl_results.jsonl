{"task_id": "HumanEval/81", "completion": "\ndef numerical_letter_grade(grades):\n    \"\"\"It is the last week of the semester and the teacher has to give the grades\n    to students. The teacher has been making her own algorithm for grading.\n    The only problem is, she has lost the code she used for grading.\n    She has given you a list of GPAs for some students and you have to write \n    a function that can output a list of letter grades using the following table:\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n    Example:\n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n    letter_grades = []\n    grade_scale = {4.0: 'A+', 3.7: 'A', 3.3: 'A-', 3.0: 'B+', 2.7: 'B', 2.3: 'B-', 2.0: 'C+', 1.7: 'C', 1.3: 'C-', 1.0: 'D+', 0.7: 'D', 0.0: 'D-', 0.0: 'E'}\n    for gpa in grades:\n        for scale in grade_scale:\n            if gpa >= scale:\n                letter_grades.append(grade_scale[scale])\n                break\n    return letter_grades\n\nprint(numerical_letter_grade([4.0, 3, 1.7, 2, 3.5]))\n\n# def numerical_letter_grade(grades):\n#    ", "result": "failed: ", "passed": false}
{"task_id": "HumanEval/101", "completion": "\ndef words_string(s):\n    \"\"\"\n    You will be given a string of words separated by commas or spaces. Your task is\n    to split the string into words and return an array of the words.\n    \n    For example:\n    words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    \"\"\"\n    return s.replace(',', '').split()\n\n\nprint(words_string(\"Hi, my name is John\"))\nprint(words_string(\"One, two, three, four, five, six\"))\n\n# Output:\n# ['Hi', 'my', 'name', 'is', 'John']\n# ['One', 'two', 'three', 'four', 'five', 'six']def count_vowels(s):\n    \"\"\"\n    Write a function that takes a string and returns the number of vowels in the string.\n    The vowels are 'a', 'e', 'i', 'o', and 'u'.\n\n    For example:\n    count_vowels(\"Hello, world\") == 3\n    count_vowels(\"This is a test\") == 3\n    \"\"\"\n    return sum(s.count(vowel) for vowel in 'aeiou')\n\n\nprint(count_vowels(\"Hello, world\"))\nprint(count_vowels(\"This is a test\"))\n\n# Output:\n# 3\n# 3def is_palindrome(s):\n    \"\"\"\n    Write a function that takes a string and returns True if the string is a palindrome and False otherwise.\n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward, ignoring spaces, punctuation, and capitalization.\n\n    For example:\n    is_palindrome(\"radar\") == True\n    is_palindrome(\"hello\") == False\n    is_palindrome(\"A man, a plan, a canal: Panama\") ==", "result": "failed: unexpected indent (<string>, line 30)", "passed": false}
{"task_id": "HumanEval/36", "completion": "\n\ndef fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(11, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count\n\n\nif __name__ == \"__s__\":\n    import doctest\n    doctest.testmod()\n    doctest.run_docstring_examples(fizz_buzz, globals(), verbose=True)\n    doctest.run_docstring_examples(fizzs__, globals(), verbose=True)\n    doctest.run_docstring_examples(fizz_buzz, globals(), verbose=True)\n    doctest.run_docstring_examples(fizz_buzz, globals(), verbose=True)\n    doctest.run_docstring_examples(fizz_buzz, globals(), verbose=True)\n    doctest.run_docstring_examples(fizz_buzz, globals(), verbose=True)\n    doctest.run_docstring_examples(fizz_buzz, globals(), verbose=True)\n    doctest.run_docstring_examples(fizz_buzz, globals(), verbose=True)\n    doctest.run_docstring_examples(fizz_buzz, globals(), verbose=True)\n    doctest.run_docstring_examples(fizz_buzz, globals(), verbose=True)\n    doctest.run_docstring_examples(fizz_buzz, globals(), verbose=True)\n    doctest.run_docstring_examples(fizz_buzz, globals(), verbose=True)\n   ", "result": "passed", "passed": true}
{"task_id": "HumanEval/88", "completion": "\ndef sort_array(array):\n    \"\"\"\n    Given an array of non-negative integers, return a copy of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \"\"\"\n    if len(array) == 0:\n        return []\n    elif len(array) == 1:\n        return [array[0]]\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            return sorted(array, reverse=True)\n        else:\n            return sorted(array)\n\n\nprint(sort_array([]))  # []\nprint(sortarray([5]))  # [5]\nprint(sort_array([2, 4, 3, 0, 1, 5]))  # [0, 1, 2, 3, 4, 5]\nprint(sort_array([2, 4, 3, 0, 1, 5, 6]))  # [6, 5, 4, 3, 2, 1, 0]\n\n# 1. \ube48 \ubc30\uc5f4\uc774 \uc8fc\uc5b4\uc9c0\uba74 \ube48 \ubc30\uc5f4\uc744 \ubc18\ud658\ud569\ub2c8\ub2e4.\n# 2. \ubc30\uc5f4\uc774", "result": "failed: name 'sortarray' is not defined", "passed": false}
{"task_id": "HumanEval/54", "completion": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return sorted(s0) == sorted(s1)\n\n\ndef same_chars_v2(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars_v2('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars_v2('abcd', 'dddddddabc')\n    True\n    >>> same_chars_v2('dddddddabc', 'abcd')\n    True\n    >>> same_chars_v2('eabcd', 'dddddddabc')\n    False\n    >>> same_chars_v2('abcd', 'dddddddabce')\n    False\n    >>> same_chars_v2('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return Counter(s0) == Counter(s1)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n#tests/test_same_chars.py\nimport pytest\nfrom same_chars import same_chars, same_chars_v2\n\n\n@pytest.mark.parametrize(\n    \"s0,s1,expected\",\n", "result": "failed: '(' was never closed (<string>, line 69)", "passed": false}
{"task_id": "HumanEval/100", "completion": "\ndef make_a_pile(n):\n    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is:\n        - the next odd number if n is odd.\n        - the next even number if n is even.\n    Return the number of stones in each level in a list, where element at index\n    i represents the number of stones in the level (i+1).\n\n    Examples:\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n    stones = [n]\n    for i in range(1, n):\n        if n % 2 == 0:\n            stones.append(n + 2 * i)\n        else:\n            stones.append(n + 2 * i)\n    return stones\n\n\ndef make_a_pile_v2(n):\n    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is:\n        - the next odd number if n is odd.\n        - the next even number if n is even.\n    Return the number of stones in each level in a list, where element at index\n    i represents the number of stones in the level (i+1).\n\n    Examples:\n    >>> make_a_pile_v2(3)\n    [3, 5, 7]\n    \"\"\"\n    stones = [n]\n    for i in range(1, n):\n        if n % 2 == 0:\n            stones.append(n + 2 * i)\n        else:\n            stones.append(n + 2 * i)\n    return stones\n\n\ndef make_a_pile_v3(n):\n    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is:\n        - the next odd number if n is odd.\n        - the next even number if n is even", "result": "failed: unterminated triple-quoted string literal (detected at line 83) (<string>, line 64)", "passed": false}
{"task_id": "HumanEval/26", "completion": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    result = []\n    for num in numbers:\n        if num not in result:\n            result.append(num)\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n\n    # Testing with a list of integers\n    numbers = [1, 2, 3, 2, 4]\n    print(remove_duplicates(numbers))  # Output: [1, 2, 3, 4]\n\n    # Testing with a list of integers\n    numbers = [1, 2, 3, 2, 4, 4, 5, 6, 7, 8, 9, 10]\n    print(remove_duplicates(numbers))  # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n    # Testing with a list of integers\n    numbers = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ", "result": "failed: '[' was never closed (<string>, line 39)", "passed": false}
{"task_id": "HumanEval/132", "completion": "\ndef is_nested(string):\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]') \u279e True\n    is_nested('[]]]]]]][[[[[]') \u279e False\n    is_nested('[][]') \u279e False\n    is_nested('[]') \u279e False\n    is_nested('[[][]]') \u279e True\n    is_nested('[[]][[') \u279e True\n    '''\n    stack = []\n    for bracket in string:\n        if bracket == '[':\n            stack.append(bracket)\n        elif bracket == ']':\n            if not stack or stack[-1] != '[':\n                return False\n            stack.pop()\n    return any(i == '[' for i in stack)\n\nprint(is_nested('[[]]')) # \u279e True\nprint(is_nested('[]]]]]]][[[[[]')) # \u279e False\nprint(is_nested('[][]')) # \u279e False\nprint(is_nested('[]')) # \u279e False\nprint(is_nested('[[][]]')) # \u279e True\nprint(is_nested('[[]][[')) # \u279e True\n\n# The function works by iterating over the string and pushing any opening brackets onto a stack.\n# When it encounters a closing bracket, it checks if the stack is empty or the last item on the stack is not an opening bracket.\n# If either of these conditions is true, it returns False. Otherwise, it pops the last item off the stack.\n# After iterating over the string, if there are any items left on the stack, it checks if any of them are opening brackets.\n# If so, it returns True. Otherwise, it returns False.\n# This is because a valid subsequence of brackets", "result": "failed: This prints if this assert fails 1 (good for debugging!)", "passed": false}
{"task_id": "HumanEval/46", "completion": "\n\ndef fib4(n: int):\n    \"\"\"The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"\n    fib = [0, 0, 2, 0]\n    for i in range(4, n+1):\n        fib.append(fib[i-1] + fib[i-2] + fib[i-3] + fib[i-4])\n    return fib[n]\n\n\ndef fib5(n: int):\n    \"\"\"The Fib5 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n    fib5(0) -> 0\n    fib5(1) -> 0\n    fib5(2) -> 0\n    fib5(3) -> 2\n    fib5(n) -> fib5(n-1) + fib5(n-2) + fib5(n-3) + fib5(n-4) + fib5(n-5).\n    Please write a function to efficiently compute the n-th element of the fib5 number sequence.  Do not use recursion.\n    >>> fib5(5)\n    2\n    >>> fib5(6)\n    4\n    >>> fib5(7)\n    6\n    >>> fib5(8)\n    10\n    \"\"\"\n    fib = [0, 0, 0, 2, 0]\n    for i in range(5, n+1):\n        fib.", "result": "failed: invalid syntax (<string>, line 60)", "passed": false}
{"task_id": "HumanEval/83", "completion": "\ndef starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\n    return 2 * (10 ** (n - 1))\n\n\ndef starts_ends_both(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start and end with 1.\n    \"\"\"\n    return 10 ** (n - )\n\n\ndef starts_ends_neither(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that neither start nor end with 1.\n    \"\"\"\n    return 8 * (10 ** (n - 2))\n\n\ndef starts_ends_either(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\n    return 10 ** (n - 1) + 10 ** (n - 1) - 2\n\n\ndef starts_ends_both_neither(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start and end with 1 and neither start nor end with 1.\n    \"\"\"\n    return 10 ** (n - 2)\n\n\ndef starts_ends_neither_both(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that neither start nor end with 1 and start and end with 1.\n    \"\"\"\n    return 10 ** (n - 2)\n\n\ndef starts_ends_both_neither_either(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start and end with 1, neither start nor end with 1, and\n    either start or end with 1.\n    \"\"\"\n    return 10 ** (n - 1)", "result": "failed: invalid syntax (<string>, line 21)", "passed": false}
{"task_id": "HumanEval/123", "completion": "\ndef get_odd_collatz(n):\n    \"\"\"\n    Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n    as follows: start with any positive integer n. Then each term is obtained from the \n    previous term as follows: if the previous term is even, the next term is one half of \n    the previous term. If the previous term is odd, the next term is 3 times the previous\n    term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n        2. returned list sorted in increasing order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\n    collatz = [n]\n    while n != 1:\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = 3 * n + 1\n        if n % 2 != 0:\n            collatz.append(n)\n    return sorted(collatz)\n\n\nprint(get_odd_collatz(5))  # [1, 5]\nprint(get(5))  # [1, 5]\nprint(get_odd_collatz(15))  # [1, 5, 11, 17, 95]\nprint(get_odd_collatz(100))  # [1, 5, 11, 17, 95, 285]\nprint(get_odd_collatz(999999))  # [1, 5, 11, 17, 95, 285, 852, 426, 213, 640, 3", "result": "failed: name 'get' is not defined", "passed": false}
{"task_id": "HumanEval/40", "completion": "\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero takes a list of integers as an input.\n    it returns True if there are three distinct elements in the list that\n    sum to zero, and False otherwise.\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n    l.sort()\n    for i in range(len(l) - 2):\n        left = i + 1\n        right = len(l) - 1\n        while left < right:\n            sum = l[i] + l[left] + l[right]\n            if sum < 0:\n                left += 1\n            elif sum > 0:\n                right -= 1\n            else:\n                return True\n    return False\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n#tests/test_triples_sum_to_zero.py\nimport pytest\nfrom triples_sum_to_zero import triples_sum_to_zero\n\n\n@pytest.mark.parametrize(\n    \"input_list, expected_output\",\n    [\n        ([1, 3, 5, 0], False),\n        ([1, 3, -2, 1], True),\n        ([1, 2, 3, 7], False),\n        ([2, 4, -5, 3, 9, 7], True),\n        ([1], False),\n    ],\n)\ndef test_triples_sum_to_zero(input_list, expected_output):\n    assert tri", "result": "failed: No module named 'triples_sum_to_zero'", "passed": false}
{"task_id": "HumanEval/75", "completion": "\ndef is_multiply_prime(a):\n    \"\"\"Write a function that returns true if the given number is the multiplication of 3 prime numbers\n    and false otherwise.\n    Knowing that (a) is less then 100. \n    Example:\n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    factors = []\n    for i in range(2, a):\n        if a % i == 0 and is_prime(i):\n            factors.append(i)\n            a //= i\n            if len(factors) > 3:\n                return False\n    return len(factors) == 3 and is_prime(a)\n\n\nprint(is_multiply_prime(30))  # True\nprint(is_multiply_prime(100))  # False\nprint(is_multiply_prime(60))  # True\nprint(is_multiply_prime(30))  # True\nprint(is_multiply_prime(100))  # False\nprint(is_multiply_prime(60))  # True\nprint(is_multiply_prime(30))  # True\nprint(is_multiply_prime(100))  # False\nprint(is_multiply_prime(60))  # True\nprint(is_multiply_prime(30))  # True\nprint(is_multiply_prime(100))  # False\nprint(is_multiply_prime(60))  # True\nprint(is_multiply_prime(30))  # True\nprint(is_multiply_prime(100))  # False\nprint(is_multiply_prime(60))  # True\nprint(is_multiply_prime(", "result": "failed: '(' was never closed (<string>, line 52)", "passed": false}
{"task_id": "HumanEval/52", "completion": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"Return True if all numbers in the list l are below threshold t.\n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    for i in l:\n        if i >= t:\n            return False\n    return True\n\n\ndef sum_of_digits(n: int):\n    \"\"\"Return the sum of the digits of n.\n    >>> sum_of_digits(1234)\n    10\n    >>> sum_of_digits(1000)\n    1\n    \"\"\"\n    return sum(int(i) for i in str(n))\n\n\ndef is_prime(n: int):\n    \"\"\"Return True if n is a prime number.\n    >>> is_prime(2)\n    True\n    >>> is_prime(1)\n    False\n    >>> is_prime(4)\n    False\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\n\ndef is_palindrome(s: str):\n    \"\"\"Return True if s is a palindrome.\n    >>> is_palindrome('radar')\n    True\n    >>> is_palindrome('python')\n    False\n    \"\"\"\n    return s == s[::-1]\n\n\ndef is_anagram(s1: str, s2: str):\n    \"\"\"Return True if s1 and s2 are anagrams.\n    >>> is_anagram('listen', 'silent')\n    True\n    >>> is_anagram('hello', 'world')\n    False\n    \"\"\"\n    return sorted(s1) == sorted(s2)\n\n\ndef is_subsequence(s1: str, s2: str):\n    \"\"\"Return True if s1 is a subsequence of s2", "result": "failed: unterminated triple-quoted string literal (detected at line 88) (<string>, line 73)", "passed": false}
{"task_id": "HumanEval/55", "completion": "\n\ndef fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    if n == 1:\n        return 1\n    elif n == 0:\n        return 0\n    else:\n        return fib(n - 1) + fib(n - 2)\n\n\ndef main():\n    import doctest\n    doctest.testmod()\n\n\nif __name__ == \"__main__\":\n    main()\n\n#lab_03/task_02.py\ndef fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    if n == 1:\n        return 1\n    elif n == 0:1\n        return 0\n    else:\n        return fib(n - 1) + fib(n - 2)\n\n\ndef main():\n    import doctest\n    doctest.testmod()\n\n\nif __name__ == \"__main__\":\n    main()\n\n#lab_03/task_03.py\ndef fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    if n == 1:\n        return 1\n    elif n == 0:\n        return 0\n    else:\n        return fib(n - 1) + fib(n - 2)\n\n\ndef main():\n    import doctest\n    doctest.testmod()\n\n\nif __name__ == \"__main__\":\n    main()\n\n#lab_03/task_04.py\ndef fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib", "result": "failed: unexpected indent (<string>, line 52)", "passed": false}
{"task_id": "HumanEval/23", "completion": "\n\ndef strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n    if string == '':\n        return 0\n    else:\n        return 1 + strlen(string[1:])\n\n\ndef strrev(string: str) -> str:\n    \"\"\" Return reversed string\n    >>> strrev('')\n    ''\n    >>> strrev('abc')\n    'cba'\n    \"\"\"\n    if string == '':\n        return ''\n    else:\n        return string[-1] + strrev(string[:-1])\n\n\ndef strsub(string: str, sub: str) -> int:\n    \"\"\" Return number of occurrences of sub in string\n    >>> strsub('', '')\n    1\n    >>> strsub('abc', '')\n    1\n    >>> strsub('abc', 'a')\n    1\n    >>> strsub('abc', 'b')\n    1\n    >>> strsub('abc', 'c')\n    1\n    >>> strsub('abc', 'ab')\n    1\n    >>> strsub('abc', 'bc')\n    1\n    >>> strsub('abc', 'abc')\n    1\n    >>> strsub('abcabc', 'abc')\n    2\n    \"\"\"\n    if sub == string:\n        return 1\n    elif sub not in string:\n        return 0\n    else:\n        return 1 + strsub(string[string.index(sub) + 1:], sub)\n\n\ndef strcmp(string1: str, string2: str) -> int:\n    \"\"\" Compare two strings\n    >>> strcmp('', '')\n    0\n    >>> strcmp('a', 'a')\n    0\n    >>> strcmp('b', 'a')\n    1\n    >>> strcmp('a', 'b')\n    -1\n    \"\"\"\n    if string1 == string2:\n        return 0\n    elif string1 < string2:\n        return -1\n    else:\n        return 1#lab", "result": "passed", "passed": true}
{"task_id": "HumanEval/102", "completion": "\ndef choose_num(x, y):\n    \"\"\"This function takes two positive numbers x and y and returns the\n    biggest even integer number that is in the range [x, y] inclusive. If \n    there's no such number, then the function should return -1.\n\n    For example:\n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n    \"\"\"\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n    return -1\n\n\nprint(choose_num(12, 15))  # 14\nprint(choose(13, 12))  # -1\nprint(choose_num(14, 15))  # 14\nprint(choose_num(15, 16))  # 16\nprint(choose_num(16, 17))  # 16\nprint(choose_num(17, 18))  # 18\nprint(choose_num(18, 19))  # 18\nprint(choose_num(19, 20))  # 20\nprint(choose_num(20, 21))  # 20\nprint(choose_num(21, 22))  # 22\nprint(choose_num(22, 23))  # 22\nprint(choose_num(23, 24))  # 24\nprint(choose_num(24, 25))  # 24\nprint(choose_num(25, 26))  # 26\nprint(choose_num(26, 27))  # 26\nprint(choose_num(27, 28))  # 28\nprint(choose_num(28, 29))  # 28\nprint(choose_num(29, 30))  # 30\nprint(choose_num(30, 31))  # 3", "result": "failed: name 'choose' is not defined", "passed": false}
{"task_id": "HumanEval/21", "completion": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    min_val = min(numbers)\n    max_val = max(numbers)\n    return [(n - min_val) / (max_val - min_val) for n in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n\n    print(rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0]))\n    # Output: [0.0, 0.25, 0.5, 0.75, 1.0]\n\n#test_rescale_to_unit.py\nimport unittest\nfrom rescale_to_unit import rescale_to_unit\n\nclass TestRescaleToUnit(unittest.TestCase):\n\n    def test_rescale_to_unit(self):\n        self.assertEqual(rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0]), [0.0, 0.25, 0.5, 0.75, 1.0])\n        self.assertEqual(rescale_to_unit([-1.0, 0.0, 1.0]), [0.0, 0.5, 1.0])\n        self.assertEqual(rescale_to_unit([0.0, 0.0, 0.0]), [0.0, 0.0, 0.0])\n\nif __name__", "result": "failed: expected ':' (<string>, line 42)", "passed": false}
{"task_id": "HumanEval/86", "completion": "\ndef anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    words = s.split(' ')\n    new_words = []\n    for word in words:\n        new_word = ''.join(sorted(word))\n        new_words.append(new_word)\n    return ' '.join(new_words)\n\n\nprint(anti_shuffle('Hello World!!!'))\nprint(anti_shuffle('Hi'))\nprint(anti_shuffle('hello'))\nprint(anti_shuffle('a quick brown fox jumps over the lazy dog'))\nprint(anti_shuffle('A Quick Brown Fox Jumps Over The Lazy Dog'))\nprint(anti_shuffle('1234567890'))\nprint(anti_shuffle('The quick brown fox jumps over the lazy dog'))\nprint(anti_shuffle('THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG'))\nprint(anti_shuffle('1234567890'))\nprint(antihi</s>)\nprint(antihi</s>)\nprint(antihi</s>)\nprint(antihi</s>)\nprint(antihi</s>)\nprint(antihi</s>)\nprint(antihi</s>)\nprint(antihi</s>)\nprint(antihi</s>)\nprint(antihi</s>)\nprint(antihi</s>)\nprint(antihi<", "result": "failed: invalid syntax (<string>, line 46)", "passed": false}
{"task_id": "HumanEval/3", "completion": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" You're given a list of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return True. Otherwise it should return False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n    balance = 0\n    for operation in operations:\n        balance += operation\n        if balance < 0:\n            return True\n    return False\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n\n#tests/test_below_zero.py\nimport unittest\nfrom below_zero import below_zero\n\nclass TestBelowZero(unittest.TestCase):\n\n    def test_below_zero(self):\n        self.assertEqual(below_zero([1, 2, 3]), False)\n        self.assertEqual(below_zero([1, 2, -4, 5]), True)\n        self.assertEqual(belowzero([1, 2, 3]), False)\n        self.assertEqual(below_zero([1, 2, -4, 5]), True)\n\nif __name__ == '__main__':\n    unittest.main()#src/config.py\nimport os\n\nclass Config:\n    SECRET_KEY = os.environ.get('SECRET_KEY')\n    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL')\n    SQLALCHEMY_TRACK_MODIFICATIONS = False\n    MAIL_SERVER = 'smtp.googlemail.com'\n    MAIL_PORT = 587\n    MAIL_USE_TLS = True\n    MAIL_USERNAME = os.environ.get('EMAIL_USER')\n    MAIL_PASSWORD = os.env", "result": "failed: No module named 'below_zero'", "passed": false}
